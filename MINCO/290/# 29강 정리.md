# 29강 정리

## sam1 모든 그래프는 하드코딩해서 순회하기

```cpp
int map[5][5] = {
    0,1,1,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
};
```

- 배열:for문으로 탐색
- 그래프나 트리는 탐색은 for가 아니야, 노드를 하나씩 순회하는걸 탐색
- 그래프 탐색은 재귀하면 된다
- 자식노드 찾는법 

```cpp
for(int i=0 ; i<map ; i++) {
    map[now][i];
}
```

- 인호강사의 말하는데 어려운점 : 노드의 Name과 노드 고유 번호를 자꾸 햇갈리게 말한다!!!
- 그래프의 순회는 절대 for문 돌리면 안된다!!

## sam2) 특정레벨에 도착했을때 경로를 출력하는 프로그램 작성

- 이건알지? PASS
- level, 기저조건

## sam3) 그래프 DFS에다가 비용이 추가됨

- 간선간 가중치가 생김
- 간선에다가 하드코딩연습하기
- 간선 가중치는 map배열에서 0,1이 아니라 숫자

```cpp
int map[4][4] = {
    0,5,7,15,
    5,0,1,6,
    7,1,0,2,
    15,6,2,0
};
```

- 여기서는 최소 비용 구하기 유형이 출제
- DFS탐색이 두가지
  - 모든 노드를 한번씩 탐색
  - 모든 경로를 탐색
- 노드탐색과 경로탐색은 다르다!!!!
- 코드상으로 노드탐색/경로탐색 보여드림
- 먼저 모든노드 탐색

```cpp
void run(int level, int now) {
    cout << value[now];

    for(int i=0 ; i<6 ; i++) {
        if(map[now][i] == 1 && used[i] == 0 ) {
            used[i] = 1;
            run(i);
            used[i] = 0;
        }
    }
}
```

- 모든경로 탐색

```cpp
void run(int level, int now) {
    cout << value[now];

    for(int i=0 ; i<6 ; i++) {
        if(map[now][i] == 1 && used[i] == 0 ) {
            used[i] = 1;
            run(i);
        }
    }
}
```

- 결국 재귀호출 run(i) 뒤에 used[i] = 0; 이거 한줄 있고없고 차이다! (1시간 9분)
- 지운거랑 안지운거 한줄인데 이해하기 힘들어요

## sam4) 외판원 순회 문제

- 가중치가 있는 그래프에서
- 출발점 A에서 도착점 B까지 이동하는데 드는 최소비용을 구하기
- 그래프 구조는 아래

```cpp
int map[4][4] = {
    0,5,15,0,
    3,0,0,4,
    0,0,0,9,
    1,0,7,0
};
```

- 유형 : 출발점 A에서 도착점 B까지 이동하는데 드는 최소비용을 구하기
- 소스코드 예시

```cpp

```

## 29강 - 1시간 40분위치에서 정리

- 그래프 문제 유형 정리

    ````s
    1. 레벨N 도착시 모두 출력(순열문제)
    2. 시작점>도착점 모든 경로를 출력  : 경로탐색
    3. 모든 노드를 탐색(방문)하고 출력하는 문제 : 노드순회
    ```

## 코딩테스트를 위한 그래프이론

- 배열 : 배열에 데이터를 저장해놓으면 인덱스를 통해서 데이터에 접근한다, for문 사용
- 링크드리스트 : Node * cur가지고 보다가 cur = cur->next; 이런식으로 똑같이 for문 사용(포인트연산)
- 트리 / 그래프
  - 그래프 그림그린거를 2차원 배열(인접행렬) 방식으로 표현하기, 그림->배열 변환 하드코딩 연습
  - 노드를 입력받아 해당 노드의 자식노드(이동가능한 노드) 출력하기
  - 부모노드 출력하기
  - 순회하기 : 자식을 찾으면 재귀호출 + (
    - visited/used[] : 그래프의 경우 싸이클링을 막기위해 필요함
    - path[] : 지나온 경로를 저장해야할때, 
    - name[] : 노드 번호랑 노드의 데이터값(value)이 다를때
  - 트리와 그래프의 차이는 사이클링 방지코드가 필요한지 아닌지만 다름!


## 2진트리(1시간52분)

- 자식노드가 최대 두명인걸 의미해요
- 이진트리를 사용할수 있는데, 이진트리를 1차원 배열에 하드코딩할수 있어서 개 빠름
- 루트노드는 1번인덱스, 0번이 아니다! 조심
- 부모노드가 N번 인덱스라고 할때, 자식왼쪽은 2N, 오른쪽 자식은 2N+1 번 인덱스
- 그러니까, 그래프에서 이진트리라고 FIX되어있는 경우에는 1차원배열에 매우 쉽게 하드코딩할 수 있다
- 하드코딩한 후 이진트리에서 DFS 돌리면 됨

```cpp
int data[] = {0,3,5,4,0,0,9,3};
```

## sam5) DFS 돌리기

- 배열의 인덱스 now 에서 1로 시작
- now 에서 들어가면 브랜치가 두개 생김
- DFS 돌릴때, 가지치기(가지치기 두가지)
- 가지치기 두가지
  - 일단 들어왔다가 잘못들어온걸 인지하고 나가기(이걸 추천 ★)
  - 처음부터 진입도 안되게 막기
- 두가지 재귀의 기저조건
  - 데이터가 0인경우( 노드가 없는경우)
  - 인덱스가 범위를 돌파하는 경우
- 순서가 중요해
- 배열사이즈 범위 초과를 먼저 검사해야지, 안그러면 런타임 에러 발생할 수 있다.

```cpp
now >= 8 || data[now] == 0
```

- 이진트리의 DFS 는 개 간단하쥬??? 이진트리일떄는 이렇게만 쓰면 게이득이다!!

## sam6) 2분7초 오늘의 마지막 보스문제

- 이진트리 탐색을 하면서 SUM을 출력해주세요
- 지금까지의 합을 출력하는 예제